package main

// Emitter that generates bevi_gen.go per package.
// - Outputs Systems(app *bevi.App)
// - Deduplicates helpers (mappers, filters, resources, event readers/writers)
// - Honors pointer-marked queries (*ecs.QueryN[T]) as WRITE intent; non-pointer queries as READ intent
// - Applies explicit annotation overrides (Reads/Writes/ResReads/ResWrites)
// - Adds event access (EventWriter/EventReader)
// - Preserves original function parameter order

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

// GenEmitter implements the Emitter interface.
type GenEmitter struct{}

func (GenEmitter) Name() string { return "GenEmitter" }

func (GenEmitter) Run(ctx *Context) error {
	for _, pkg := range ctx.Packages {
		if len(pkg.SysSpecs) == 0 {
			continue
		}

		src, err := emitPackage(ctx, pkg)
		if err != nil {
			return fmt.Errorf("emit %s: %w", pkg.Dir, err)
		}
		if ctx.Options.Write {
			outPath := filepath.Join(pkg.Dir, "bevi_gen.go")
			if err := os.WriteFile(outPath, src, 0o644); err != nil {
				return fmt.Errorf("write %s: %w", outPath, err)
			}
			ctx.Logger("wrote %s", outPath)
		} else {
			fmt.Printf("===== %s/bevi_gen.go =====\n%s\n", pkg.Dir, string(src))
		}
	}
	return nil
}

func emitPackage(ctx *Context, pkg *Package) ([]byte, error) {
	var buf bytes.Buffer
	w := func(format string, args ...any) {
		fmt.Fprintf(&buf, format, args...)
	}

	// Header
	w("// Code generated by bevi gen; DO NOT EDIT.\n")
	w("// Generated at %s\n\n", time.Now().Format(time.RFC3339))
	w("package %s\n\n", pkg.Name)

	// Imports we may need based on observed params/metadata
	imports := map[string]bool{
		`"github.com/oriumgames/bevi"`:   true,
		`"github.com/mlange-42/ark/ecs"`: true,
		`"context"`:                      true,
	}
	useTime := false

	// Pre-compute helper declarations per package (dedup)
	helpers := make([]genHelper, 0, 8)
	ensureHelper := func(k ParamKind, key string, typs []string) string {
		for i, h := range helpers {
			if h.key == key {
				return helperName(i, h)
			}
		}
		helpers = append(helpers, genHelper{key: key, kind: k, typs: append([]string(nil), typs...)})
		return helperName(len(helpers)-1, genHelper{})
	}

	// Determine helpers to allocate
	for _, sys := range pkg.SysSpecs {
		if sys.Every != nil {
			useTime = true
		}
		for _, p := range sys.Params {
			switch p.Kind {
			case ParamECSMap:
				_ = ensureHelper(p.Kind, p.HelperKey, p.ElemTypes)
			case ParamECSQuery, ParamECSFilter, ParamECSBatch:
				_ = ensureHelper(p.Kind, p.HelperKey, p.ElemTypes)
			case ParamECSResource:
				_ = ensureHelper(p.Kind, p.HelperKey, p.ElemTypes)
			case ParamEventWriter:
				_ = ensureHelper(p.Kind, p.HelperKey, p.ElemTypes)
			case ParamEventReader:
				_ = ensureHelper(p.Kind, p.HelperKey, p.ElemTypes)
			}
		}
	}
	if useTime {
		imports[`"time"`] = true
	}

	// Write imports
	var impKeys []string
	for k := range imports {
		impKeys = append(impKeys, k)
	}
	sort.Strings(impKeys)
	w("import (\n")
	for _, k := range impKeys {
		w("\t%s\n", k)
	}
	w(")\n\n")

	// Systems function signature
	w("func Systems(app *bevi.App) {\n")

	// Declare helpers
	for i, h := range helpers {
		name := helperName(i, h)
		switch h.kind {
		case ParamECSMap:
			// ecs.NewMapN[T...](app.World())
			gname, err := genericTypeList(h.typs)
			if err != nil {
				return nil, err
			}
			w("\t%s := ecs.NewMap%d[%s](app.World())\n", name, len(h.typs), gname)
		case ParamECSQuery, ParamECSFilter, ParamECSBatch:
			// ecs.NewFilterN[T...](app.World())
			gname, err := genericTypeList(h.typs)
			if err != nil {
				return nil, err
			}
			w("\t%s := ecs.NewFilter%d[%s](app.World())\n", name, len(h.typs), gname)
		case ParamECSResource:
			// ecs.NewResource[T](app.World())
			if len(h.typs) != 1 {
				return nil, fmt.Errorf("resource expects 1 type param, got %v", h.typs)
			}
			w("\t%s := ecs.NewResource[%s](app.World())\n", name, h.typs[0])
		case ParamEventWriter:
			// bevi.WriterFor[T](app.Events())
			if len(h.typs) != 1 {
				return nil, fmt.Errorf("event writer expects 1 type param, got %v", h.typs)
			}
			w("\t%s := bevi.WriterFor[%s](app.Events())\n", name, h.typs[0])
		case ParamEventReader:
			// bevi.ReaderFor[T](app.Events())
			if len(h.typs) != 1 {
				return nil, fmt.Errorf("event reader expects 1 type param, got %v", h.typs)
			}
			w("\t%s := bevi.ReaderFor[%s](app.Events())\n", name, h.typs[0])
		default:
			// ignore
		}
	}
	if len(helpers) > 0 {
		w("\n")
	}

	// Emit AddSystem entries
	for _, sys := range pkg.SysSpecs {
		// Build AccessMeta inference with priority:
		// - Default: Query -> READ; pointer-marked Query (*ecs.QueryN[T]) -> WRITE
		//            Map -> WRITE; Resource -> ResREAD
		// - Event access from params
		// - Explicit annotation overrides applied after defaults (Reads removes Write)
		compRead := map[string]bool{}
		compWrite := map[string]bool{}
		resRead := map[string]bool{}
		resWrite := map[string]bool{}
		eventLines := []string{}
		for _, p := range sys.Params {
			switch p.Kind {
			case ParamEventWriter:
				if len(p.ElemTypes) == 1 {
					eventLines = append(eventLines, fmt.Sprintf("bevi.AccessEventWrite[%s](&acc)", p.ElemTypes[0]))
				}
			case ParamEventReader:
				if len(p.ElemTypes) == 1 {
					eventLines = append(eventLines, fmt.Sprintf("bevi.AccessEventRead[%s](&acc)", p.ElemTypes[0]))
				}
			case ParamECSQuery, ParamECSFilter, ParamECSBatch:
				// Pointer-marked queries imply WRITE; non-pointer default to READ
				if p.Pointer {
					for _, t := range p.ElemTypes {
						compWrite[t] = true
					}
				} else {
					for _, t := range p.ElemTypes {
						compRead[t] = true
					}
				}
			case ParamECSMap:
				for _, t := range p.ElemTypes {
					compWrite[t] = true
				}
			case ParamECSResource:
				for _, t := range p.ElemTypes {
					resRead[t] = true
				}
			}
		}
		// Explicit overrides from annotation.
		for _, t := range sys.CompReads {
			compRead[t] = true
			delete(compWrite, t)
		}
		for _, t := range sys.CompWrites {
			compWrite[t] = true
		}
		for _, t := range sys.ResReads {
			resRead[t] = true
			delete(resWrite, t)
		}
		for _, t := range sys.ResWrites {
			resWrite[t] = true
		}
		// Compose final lines; write dominates read
		accessLines := make([]string, 0, len(eventLines)+len(compRead)+len(compWrite)+len(resRead)+len(resWrite))
		accessLines = append(accessLines, eventLines...)
		for t := range compWrite {
			accessLines = append(accessLines, fmt.Sprintf("bevi.AccessWrite[%s](&acc)", t))
		}
		for t := range compRead {
			if !compWrite[t] {
				accessLines = append(accessLines, fmt.Sprintf("bevi.AccessRead[%s](&acc)", t))
			}
		}
		for t := range resWrite {
			accessLines = append(accessLines, fmt.Sprintf("bevi.AccessResWrite[%s](&acc)", t))
		}
		for t := range resRead {
			if !resWrite[t] {
				accessLines = append(accessLines, fmt.Sprintf("bevi.AccessResRead[%s](&acc)", t))
			}
		}
		sort.Strings(accessLines)

		// Meta
		w("\t// System: %s (from %s)\n", sys.FuncName, relPath(pkg.Dir, sys.FilePath))
		w("\t{\n")
		w("\t\tacc := bevi.NewAccess()\n")
		for _, ln := range accessLines {
			w("\t\t%s\n", ln)
		}
		after := sliceLiteral(sys.After)
		before := sliceLiteral(sys.Before)
		if sys.Every != nil {
			w("\t\tmeta := bevi.SystemMeta{Access: acc, Set: %s, Before: %s, After: %s, Every: %s}\n",
				strOrNil(sys.Set), before, after, durationLiteral(*sys.Every))
		} else {
			w("\t\tmeta := bevi.SystemMeta{Access: acc, Set: %s, Before: %s, After: %s}\n",
				strOrNil(sys.Set), before, after)
		}

		// Wrapper: preserve original parameter order
		w("\t\tapp.AddSystem(bevi.%s, %q, meta, func(ctx context.Context, w *ecs.World) {\n", sys.Stage, sys.SystemName)
		var args []string
		tmpIdx := 0
		for _, p := range sys.Params {
			switch p.Kind {
			case ParamContext:
				args = append(args, "ctx")
			case ParamWorld:
				args = append(args, "w")
			case ParamECSMap:
				name := findHelperName(helpers, p.HelperKey)
				if name == "" {
					return nil, fmt.Errorf("internal: missing map helper for %v", p.ElemTypes)
				}
				args = append(args, name)
			case ParamECSQuery:
				name := findHelperName(helpers, p.HelperKey)
				if name == "" {
					return nil, fmt.Errorf("internal: missing query helper for %v", p.ElemTypes)
				}
				if p.Pointer {
					tmp := fmt.Sprintf("_q%d", tmpIdx)
					tmpIdx++
					w("\t\t\t%s := %s.Query()\n", tmp, name)
					args = append(args, "&"+tmp)
				} else {
					args = append(args, fmt.Sprintf("%s.Query()", name))
				}
			case ParamECSFilter:
				name := findHelperName(helpers, p.HelperKey)
				if name == "" {
					return nil, fmt.Errorf("internal: missing filter helper for %v", p.ElemTypes)
				}
				args = append(args, name)
			case ParamECSBatch:
				name := findHelperName(helpers, p.HelperKey)
				if name == "" {
					return nil, fmt.Errorf("internal: missing batch helper for %v", p.ElemTypes)
				}
				if p.Pointer {
					tmp := fmt.Sprintf("_b%d", tmpIdx)
					tmpIdx++
					w("\t\t\t%s := %s.Batch()\n", tmp, name)
					args = append(args, "&"+tmp)
				} else {
					args = append(args, fmt.Sprintf("%s.Batch()", name))
				}
			case ParamECSResource:
				name := findHelperName(helpers, p.HelperKey)
				if name == "" {
					return nil, fmt.Errorf("internal: missing resource helper for %v", p.ElemTypes)
				}
				args = append(args, name)
			case ParamEventWriter:
				name := findHelperName(helpers, p.HelperKey)
				if name == "" {
					return nil, fmt.Errorf("internal: missing event writer helper for %v", p.ElemTypes)
				}
				args = append(args, name)
			case ParamEventReader:
				name := findHelperName(helpers, p.HelperKey)
				if name == "" {
					return nil, fmt.Errorf("internal: missing event reader helper for %v", p.ElemTypes)
				}
				args = append(args, name)
			default:
				return nil, fmt.Errorf("unsupported parameter in %s: %s", sys.FuncName, p.TypeExpr)
			}
		}
		w("\t\t\t%s(%s)\n", sys.FuncName, strings.Join(args, ", "))
		w("\t\t})\n")
		w("\t}\n\n")
	}

	w("}\n")
	// Format
	src, err := format.Source(buf.Bytes())
	if err != nil {
		// return unformatted to help debug
		return buf.Bytes(), fmt.Errorf("format error: %w", err)
	}
	return src, nil
}

func helperName(i int, h genHelper) string {
	// Stable helper name by index and kind prefix
	prefix := "h"
	switch h.kind {
	case ParamECSMap:
		prefix = "map"
	case ParamECSQuery, ParamECSFilter, ParamECSBatch:
		prefix = "flt"
	case ParamECSResource:
		prefix = "res"
	case ParamEventWriter:
		prefix = "ew"
	case ParamEventReader:
		prefix = "er"
	default:
		prefix = "h"
	}
	return fmt.Sprintf("_%s_%d", prefix, i)
}

func findHelperName(hs []genHelper, key string) string {
	for i, h := range hs {
		if h.key == key {
			return helperName(i, h)
		}
	}
	return ""
}
