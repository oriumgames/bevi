package main

// Emitter that generates bevi_gen.go per package.
// - Outputs Systems(app *bevi.App)
// - Deduplicates helpers (mappers, filters, resources, event readers/writers)
// - Honors pointer-marked queries (*ecs.QueryN[T]) as WRITE intent; non-pointer queries as READ intent
// - Applies explicit annotation overrides (Reads/Writes/ResReads/ResWrites)
// - Adds event access (EventWriter/EventReader)
// - Preserves original function parameter order

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"
	"time"
	"unicode"
)

// GenEmitter implements the Emitter interface.
type GenEmitter struct{}

func (GenEmitter) Name() string { return "GenEmitter" }

func (GenEmitter) Run(ctx *Context) error {
	for _, pkg := range ctx.Packages {
		if len(pkg.SysSpecs) == 0 {
			continue
		}

		src, err := emitPackage(ctx, pkg)
		if err != nil {
			return fmt.Errorf("emit %s: %w", pkg.Dir, err)
		}
		if ctx.Options.Write {
			outPath := filepath.Join(pkg.Dir, "bevi_gen.go")
			if err := os.WriteFile(outPath, src, 0o644); err != nil {
				return fmt.Errorf("write %s: %w", outPath, err)
			}
			ctx.Logger("wrote %s", outPath)
		} else {
			fmt.Printf("===== %s/bevi_gen.go =====\n%s\n", pkg.Dir, string(src))
		}
	}
	return nil
}

func emitPackage(ctx *Context, pkg *Package) ([]byte, error) {
	var buf bytes.Buffer
	w := func(format string, args ...any) {
		fmt.Fprintf(&buf, format, args...)
	}

	// Header
	w("// Code generated by bevi gen; DO NOT EDIT.\n")
	w("// Generated at %s\n\n", time.Now().Format(time.RFC3339))
	w("package %s\n\n", pkg.Name)

	// Imports we may need based on observed params/metadata (path -> alias; empty alias means unaliased)
	imports := map[string]string{
		"github.com/oriumgames/bevi":   "",
		"github.com/mlange-42/ark/ecs": "",
		"context":                      "",
	}
	useTime := false

	// Pre-compute helper declarations per package (dedup)
	helpers := make([]genHelper, 0, 8)
	ensureHelper := func(k ParamKind, key string, typs []string) string {
		for i, h := range helpers {
			if h.key == key {
				return helperName(i, h)
			}
		}
		helpers = append(helpers, genHelper{key: key, kind: k, typs: append([]string(nil), typs...)})
		return helperName(len(helpers)-1, genHelper{})
	}

	// Determine helpers to allocate
	for _, sys := range pkg.SysSpecs {
		if sys.Every != nil {
			useTime = true
		}
		for _, p := range sys.Params {
			switch p.Kind {
			case ParamECSMap:
				_ = ensureHelper(p.Kind, p.HelperKey, p.ElemTypes)
			case ParamECSQuery, ParamECSFilter:
				// Build a helper key augmented with per-parameter filter options to avoid duplicates.
				key := p.HelperKey
				if len(p.FilterOpts.With) > 0 || len(p.FilterOpts.Without) > 0 || p.FilterOpts.Exclusive || p.FilterOpts.Register {
					var parts []string
					parts = append(parts, key)
					if len(p.FilterOpts.With) > 0 {
						parts = append(parts, "with:"+strings.Join(p.FilterOpts.With, ","))
					}
					if len(p.FilterOpts.Without) > 0 {
						parts = append(parts, "without:"+strings.Join(p.FilterOpts.Without, ","))
					}
					if p.FilterOpts.Exclusive {
						parts = append(parts, "exclusive")
					}
					if p.FilterOpts.Register {
						parts = append(parts, "register")
					}
					key = strings.Join(parts, "|")
				}
				_ = ensureHelper(p.Kind, key, p.ElemTypes)
			case ParamECSResource:
				_ = ensureHelper(p.Kind, p.HelperKey, p.ElemTypes)
			case ParamEventWriter:
				_ = ensureHelper(p.Kind, p.HelperKey, p.ElemTypes)
			case ParamEventReader:
				_ = ensureHelper(p.Kind, p.HelperKey, p.ElemTypes)
			}
		}
	}
	if useTime {
		imports["time"] = ""
	}

	// Synthesize extra imports discovered from source files (normal and blank imports).
	// Provided by analyzers via System.ExtraImports (alias -> import path).
	// Only include imports whose aliases are referenced in generated type strings or annotations.
	required := map[string]bool{}
	for _, sys := range pkg.SysSpecs {
		for _, p := range sys.Params {
			for _, t := range p.ElemTypes {
				if al := aliasFromTypeName(t); al != "" {
					required[al] = true
				}
			}
			for _, t := range p.FilterOpts.With {
				if al := aliasFromTypeName(t); al != "" {
					required[al] = true
				}
			}
			for _, t := range p.FilterOpts.Without {
				if al := aliasFromTypeName(t); al != "" {
					required[al] = true
				}
			}
		}
		// Also include aliases referenced by explicit access annotations.
		for _, t := range sys.CompReads {
			if al := aliasFromTypeName(t); al != "" {
				required[al] = true
			}
		}
		for _, t := range sys.CompWrites {
			if al := aliasFromTypeName(t); al != "" {
				required[al] = true
			}
		}
		for _, t := range sys.ResReads {
			if al := aliasFromTypeName(t); al != "" {
				required[al] = true
			}
		}
		for _, t := range sys.ResWrites {
			if al := aliasFromTypeName(t); al != "" {
				required[al] = true
			}
		}
	}
	for _, sys := range pkg.SysSpecs {
		for alias, ip := range sys.ExtraImports {
			if !required[alias] {
				continue
			}
			// If this path is already present, prefer the existing (usually unaliased) entry.
			if _, exists := imports[ip]; !exists {
				imports[ip] = alias
			}
		}
	}

	// Write imports (deduplicated by path; prefer unaliased for core deps).
	// If an alias equals the default import name (last path segment) and there is no conflict,
	// omit the alias to keep imports clean.
	var paths []string
	for p := range imports {
		paths = append(paths, p)
	}
	sort.Strings(paths)
	baseCount := map[string]int{}
	for _, p := range paths {
		baseCount[path.Base(p)]++
	}
	w("import (\n")
	for _, p := range paths {
		al := imports[p]
		b := path.Base(p)
		if al == "" || (al == b && baseCount[b] == 1) {
			w("\t%q\n", p)
		} else {
			w("\t%s %q\n", al, p)
		}
	}
	w(")\n\n")

	// Systems function signature
	w("func Systems(app *bevi.App) {\n")

	// Declare helpers
	for i, h := range helpers {
		name := helperName(i, h)
		switch h.kind {
		case ParamECSMap:
			// ecs.NewMapN[T...](app.World())
			gname, err := genericTypeList(h.typs)
			if err != nil {
				return nil, err
			}
			w("\t%s := ecs.NewMap%d[%s](app.World())\n", name, len(h.typs), gname)
		case ParamECSQuery, ParamECSFilter:
			// ecs.NewFilterN[T...](app.World()) with chained options parsed from helper key
			gname, err := genericTypeList(h.typs)
			if err != nil {
				return nil, err
			}
			w("\t%s := ecs.NewFilter%d[%s](app.World())\n", name, len(h.typs), gname)
			// Parse options from key: "...|with:a,b|without:c|exclusive|register"
			{
				parts := strings.Split(h.key, "|")
				withs := []string{}
				withouts := []string{}
				excl := false
				reg := false
				for _, seg := range parts[1:] {
					if after, ok := strings.CutPrefix(seg, "with:"); ok {
						items := strings.SplitSeq(after, ",")
						for it := range items {
							it = strings.TrimSpace(it)
							if it != "" {
								withs = append(withs, it)
							}
						}
					} else if after, ok := strings.CutPrefix(seg, "without:"); ok {
						items := strings.SplitSeq(after, ",")
						for it := range items {
							it = strings.TrimSpace(it)
							if it != "" {
								withouts = append(withouts, it)
							}
						}
					} else if seg == "exclusive" {
						excl = true
					} else if seg == "register" {
						reg = true
					}
				}
				if len(withs) > 0 {
					w("\t%s = %s.With(", name, name)
					for i, t := range withs {
						if i > 0 {
							w(", ")
						}
						w("ecs.C[%s]()", t)
					}
					w(")\n")
				}
				if len(withouts) > 0 {
					w("\t%s = %s.Without(", name, name)
					for i, t := range withouts {
						if i > 0 {
							w(", ")
						}
						w("ecs.C[%s]()", t)
					}
					w(")\n")
				}
				if excl {
					w("\t%s = %s.Exclusive()\n", name, name)
				}
				if reg {
					w("\t%s = %s.Register()\n", name, name)
				}
			}
		case ParamECSResource:
			// ecs.NewResource[T](app.World())
			if len(h.typs) != 1 {
				return nil, fmt.Errorf("resource expects 1 type param, got %v", h.typs)
			}
			w("\t%s := ecs.NewResource[%s](app.World())\n", name, h.typs[0])
		case ParamEventWriter:
			// bevi.WriterFor[T](app.Events())
			if len(h.typs) != 1 {
				return nil, fmt.Errorf("event writer expects 1 type param, got %v", h.typs)
			}
			w("\t%s := bevi.WriterFor[%s](app.Events())\n", name, h.typs[0])
		case ParamEventReader:
			// bevi.ReaderFor[T](app.Events())
			if len(h.typs) != 1 {
				return nil, fmt.Errorf("event reader expects 1 type param, got %v", h.typs)
			}
			w("\t%s := bevi.ReaderFor[%s](app.Events())\n", name, h.typs[0])
		default:
			// ignore
		}
	}
	if len(helpers) > 0 {
		w("\n")
	}

	// Emit AddSystem entries
	for _, sys := range pkg.SysSpecs {
		// Build AccessMeta inference with priority:
		// - Default: Query -> READ; pointer-marked Query (*ecs.QueryN[T]) -> WRITE
		//            Map -> WRITE; Resource -> ResREAD
		// - Event access from params
		// - Explicit annotation overrides applied after defaults (Reads removes Write)
		compRead := map[string]bool{}
		compWrite := map[string]bool{}
		resRead := map[string]bool{}
		resWrite := map[string]bool{}
		eventLines := []string{}
		for _, p := range sys.Params {
			switch p.Kind {
			case ParamEventWriter:
				if len(p.ElemTypes) == 1 {
					eventLines = append(eventLines, fmt.Sprintf("bevi.AccessEventWrite[%s](&acc)", p.ElemTypes[0]))
				}
			case ParamEventReader:
				if len(p.ElemTypes) == 1 {
					eventLines = append(eventLines, fmt.Sprintf("bevi.AccessEventRead[%s](&acc)", p.ElemTypes[0]))
				}
			case ParamECSQuery:
				// Pointer-marked queries imply WRITE; non-pointer default to READ
				if p.Pointer {
					for _, t := range p.ElemTypes {
						compWrite[t] = true
					}
				} else {
					for _, t := range p.ElemTypes {
						compRead[t] = true
					}
				}
			case ParamECSMap:
				for _, t := range p.ElemTypes {
					compWrite[t] = true
				}
			case ParamECSResource:
				for _, t := range p.ElemTypes {
					resRead[t] = true
				}
			}
		}
		// Explicit overrides from annotation.
		for _, t := range sys.CompReads {
			compRead[t] = true
			delete(compWrite, t)
		}
		for _, t := range sys.CompWrites {
			compWrite[t] = true
		}
		for _, t := range sys.ResReads {
			resRead[t] = true
			delete(resWrite, t)
		}
		for _, t := range sys.ResWrites {
			resWrite[t] = true
		}
		// Compose final lines; write dominates read
		accessLines := make([]string, 0, len(eventLines)+len(compRead)+len(compWrite)+len(resRead)+len(resWrite))
		accessLines = append(accessLines, eventLines...)
		for t := range compWrite {
			accessLines = append(accessLines, fmt.Sprintf("bevi.AccessWrite[%s](&acc)", t))
		}
		for t := range compRead {
			if !compWrite[t] {
				accessLines = append(accessLines, fmt.Sprintf("bevi.AccessRead[%s](&acc)", t))
			}
		}
		for t := range resWrite {
			accessLines = append(accessLines, fmt.Sprintf("bevi.AccessResWrite[%s](&acc)", t))
		}
		for t := range resRead {
			if !resWrite[t] {
				accessLines = append(accessLines, fmt.Sprintf("bevi.AccessResRead[%s](&acc)", t))
			}
		}
		sort.Strings(accessLines)

		// Meta
		w("\t// System: %s (from %s)\n", sys.FuncName, relPath(pkg.Dir, sys.FilePath))
		w("\t{\n")
		w("\t\tacc := bevi.NewAccess()\n")
		for _, ln := range accessLines {
			w("\t\t%s\n", ln)
		}
		after := sliceLiteral(sys.After)
		before := sliceLiteral(sys.Before)
		if sys.Every != nil {
			w("\t\tmeta := bevi.SystemMeta{Access: acc, Set: %s, Before: %s, After: %s, Every: %s}\n",
				strOrNil(sys.Set), before, after, durationLiteral(*sys.Every))
		} else {
			w("\t\tmeta := bevi.SystemMeta{Access: acc, Set: %s, Before: %s, After: %s}\n",
				strOrNil(sys.Set), before, after)
		}

		// Wrapper: preserve original parameter order
		w("\t\tapp.AddSystem(bevi.%s, %q, meta, func(ctx context.Context, w *ecs.World) {\n", sys.Stage, sys.SystemName)
		var args []string
		var closes []string
		tmpIdx := 0
		for _, p := range sys.Params {
			switch p.Kind {
			case ParamContext:
				args = append(args, "ctx")
			case ParamWorld:
				args = append(args, "w")
			case ParamECSMap:
				name := findHelperName(helpers, p.HelperKey)
				if name == "" {
					return nil, fmt.Errorf("internal: missing map helper for %v", p.ElemTypes)
				}
				args = append(args, name)
			case ParamECSQuery:
				// Lookup helper name using an augmented key that includes per-param filter options.
				key := p.HelperKey
				if len(p.FilterOpts.With) > 0 || len(p.FilterOpts.Without) > 0 || p.FilterOpts.Exclusive || p.FilterOpts.Register {
					var parts []string
					parts = append(parts, key)
					if len(p.FilterOpts.With) > 0 {
						parts = append(parts, "with:"+strings.Join(p.FilterOpts.With, ","))
					}
					if len(p.FilterOpts.Without) > 0 {
						parts = append(parts, "without:"+strings.Join(p.FilterOpts.Without, ","))
					}
					if p.FilterOpts.Exclusive {
						parts = append(parts, "exclusive")
					}
					if p.FilterOpts.Register {
						parts = append(parts, "register")
					}
					key = strings.Join(parts, "|")
				}
				name := findHelperName(helpers, key)
				if name == "" {
					return nil, fmt.Errorf("internal: missing query helper for %v", p.ElemTypes)
				}
				if p.Pointer {
					tmp := fmt.Sprintf("_q%d", tmpIdx)
					tmpIdx++
					w("\t\t\t%s := %s.Query()\n", tmp, name)
					args = append(args, "&"+tmp)
					closes = append(closes, tmp)
				} else {
					tmp := fmt.Sprintf("_q%d", tmpIdx)
					tmpIdx++
					w("\t\t\t%s := %s.Query()\n", tmp, name)
					args = append(args, tmp)
					closes = append(closes, tmp)
				}
			case ParamECSFilter:
				// Lookup helper for filter param and pass it directly
				key := p.HelperKey
				if len(p.FilterOpts.With) > 0 || len(p.FilterOpts.Without) > 0 || p.FilterOpts.Exclusive || p.FilterOpts.Register {
					var parts []string
					parts = append(parts, key)
					if len(p.FilterOpts.With) > 0 {
						parts = append(parts, "with:"+strings.Join(p.FilterOpts.With, ","))
					}
					if len(p.FilterOpts.Without) > 0 {
						parts = append(parts, "without:"+strings.Join(p.FilterOpts.Without, ","))
					}
					if p.FilterOpts.Exclusive {
						parts = append(parts, "exclusive")
					}
					if p.FilterOpts.Register {
						parts = append(parts, "register")
					}
					key = strings.Join(parts, "|")
				}
				name := findHelperName(helpers, key)
				if name == "" {
					return nil, fmt.Errorf("internal: missing filter helper for %v", p.ElemTypes)
				}
				args = append(args, name)

			case ParamECSResource:
				name := findHelperName(helpers, p.HelperKey)
				if name == "" {
					return nil, fmt.Errorf("internal: missing resource helper for %v", p.ElemTypes)
				}
				args = append(args, name)
			case ParamEventWriter:
				name := findHelperName(helpers, p.HelperKey)
				if name == "" {
					return nil, fmt.Errorf("internal: missing event writer helper for %v", p.ElemTypes)
				}
				args = append(args, name)
			case ParamEventReader:
				name := findHelperName(helpers, p.HelperKey)
				if name == "" {
					return nil, fmt.Errorf("internal: missing event reader helper for %v", p.ElemTypes)
				}
				args = append(args, name)
			default:
				return nil, fmt.Errorf("unsupported parameter in %s: %s", sys.FuncName, p.TypeExpr)
			}
		}
		w("\t\t\t%s(%s)\n", sys.FuncName, strings.Join(args, ", "))
		for _, c := range closes {
			w("\t\t\tif %s.Next() { %s.Close() }\n", c, c)
		}
		w("\t\t})\n")
		w("\t}\n\n")
	}

	w("}\n")
	// Format
	src, err := format.Source(buf.Bytes())
	if err != nil {
		// return unformatted to help debug
		return buf.Bytes(), fmt.Errorf("format error: %w", err)
	}
	return src, nil
}

func helperName(i int, h genHelper) string {
	// Stable helper name by index and kind prefix
	prefix := "h"
	switch h.kind {
	case ParamECSMap:
		prefix = "map"
	case ParamECSQuery, ParamECSFilter:
		prefix = "flt"
	case ParamECSResource:
		prefix = "res"
	case ParamEventWriter:
		prefix = "ew"
	case ParamEventReader:
		prefix = "er"
	default:
		prefix = "h"
	}
	return fmt.Sprintf("_%s_%d", prefix, i)
}

func findHelperName(hs []genHelper, key string) string {
	for i, h := range hs {
		if h.key == key {
			return helperName(i, h)
		}
	}
	return ""
}

func isIdent(s string) bool {
	if s == "" {
		return false
	}
	for i, r := range s {
		if i == 0 {
			if !(unicode.IsLetter(r) || r == '_') {
				return false
			}
		} else {
			if !(unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_') {
				return false
			}
		}
	}
	return true
}

func aliasFromTypeName(s string) string {
	s = strings.TrimSpace(s)
	if s == "" {
		return ""
	}
	if i := strings.IndexByte(s, '.'); i > 0 && isIdent(s[:i]) {
		return s[:i]
	}
	return ""
}
